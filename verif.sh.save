



`bash
#!/bin/bash

# Correction du comportement d'ouverture du shell
# Il s'agit d'une mauvaise interprétation : si `docker-compose up` ou `docker compose up`
# est exécuté sans `-d`, il ouvre les logs interactifs dans le shell courant.
# Il faut donc s'assurer d'exécuter le mode détaché (`-d`)

PUBLIC_INTERFACE="eth0"
TARGET_PORTS=(9200 5601)
DOCKER_NETWORK_NAME="uqac_siem_elk"
LOCAL_BINDING_PATTERN="127.0.0.1:"
DOCKER_COMPOSE_FILE="docker-compose.yml"
DOCKER_COMPOSE_BIN="/usr/local/bin/docker-compose"

detect_docker_compose() {
  if command -v docker-compose &>/dev/null; then
    DOCKER_COMPOSE_BIN=$(command -v docker-compose)
    return 0
  fi

  if docker compose version &>/dev/null; then
    DOCKER_COMPOSE_BIN="docker compose"
    return 0
  fi

  printf "❌ docker-compose not found. Install it or use Docker Compose v2 plugin.\n" >&2
  return 1
}

sanitize_network_name() {
  local existing;
  existing=$(docker network ls --format '{{.Name}}' | grep -Fx "$DOCKER_NETWORK_NAME")
  if [[ -z "$existing" ]]; then
    printf "❌ Docker network '%s' not found despite being listed.\n" "$DOCKER_NETWORK_NAME" >&2
    return 1
  fi
}

check_port_binding() {
  local port=$1
  if grep -q "${LOCAL_BINDING_PATTERN}${port}" "$DOCKER_COMPOSE_FILE"; then
    printf "❌ Port %s is bound to localhost. External access will FAIL.\n" "$port" >&2
    return 1
  fi
}

recommend_port_fix() {
  local port=$1
  sed -i "s/\"127.0.0.1:${port}:${port}\"/\"${port}:${port}\"/" "$DOCKER_COMPOSE_FILE"
  printf "✅ Updated port %s to allow external access.\n" "$port"
}

check_container_health() {
  local container=$1
  local status;
  status=$(docker inspect -f '{{.State.Health.Status}}' "$container" 2>/dev/null)
  if [[ "$status" != "healthy" ]]; then
    printf "❌ Container '%s' is NOT healthy (status: %s).\n" "$container" "$status" >&2
    return 1
  fi
}

verify_service_connectivity() {
  local ip;
  ip=$(ip -4 addr show "$PUBLIC_INTERFACE" | grep -oP '(?<=inet\s)\d+(\.\d+){3}')
  if [[ -z "$ip" ]]; then
    printf "❌ Unable to extract IP from interface %s.\n" "$PUBLIC_INTERFACE" >&2
    return 1
  fi

  local port=$1
  if ! curl -fs --connect-timeout 2 "http://${ip}:${port}" &>/dev/null; then
    printf "❌ No response from http://%s:%s\n" "$ip" "$port" >&2
    return 1
  fi

  printf "✅ Successfully connected to http://%s:%s\n" "$ip" "$port"
}

restart_containers_detached() {
  if [[ "$DOCKER_COMPOSE_BIN" == "docker compose" ]]; then
    docker compose down
    docker compose up -d
  else
    "$DOCKER_COMPOSE_BIN" down
    "$DOCKER_COMPOSE_BIN" up -d
  fi
}

main() {
  if ! detect_docker_compose; then
    return 1
  fi

  if ! sanitize_network_name; then
    return 1
  fi

  local fixed_ports=0

  for port in "${TARGET_PORTS[@]}"; do
    if ! check_port_binding "$port"; then
      recommend_port_fix "$port"
      fixed_ports=1
    fi
  done

  if (( fixed_ports == 1 )); then
    printf "⚠️ Restarting containers to apply port changes...\n"
    restart_containers_detached
  fi

  if ! check_container_health elasticsearch; then
    return 1
  fi

  if ! check_container_health kibana; then
    return 1
  fi

  for port in "${TARGET_PORTS[@]}"; do
    verify_service_connectivity "$port"
  done
}

main
```

